"""
Graded Response Models
"""

import jax
import jax.numpy as jnp
from jax import jit

from .base import Ordinal


class GRM(Ordinal):
    """A Class for Fitting Graded Response Models (GRMs)

    Attributes:
        y (jax.numpy.ndarray):
            A 3D array with shape `(n_cases, n_item, n_cats)` to represent one-hot encoding data for IFA.
        freq (jax.numpy.ndarray):
            A 1D array with shape `(n_cases,)` to represent frequencies for rows of data.
        verbose (bool):
            A `bool` to specify whether model information should be printed after successful initialization.
        key (numpy.ndarray-like):
            A pseudorandom number generator (PRNG) key for random number generation.
        info (list):
            A `list` to represent model information.
        crf (funtion):
            A `function` to calculate category responses.
        params (list):
            A `list` for model parameter matrices.
            `params` includes three parameter arrays:
            (1) `params[`intercept`]` is an intercept matrix with shape `(n_items, n_cats + 1)`;
            (2) `params[`loading`]` is a loading matrix with shape `(n_items, n_factors)`;
            (3) `params[`corr`]` is a correlation matrix with shape `(n_factors, n_factors)`.
        masks (list):
            A `list` for model parameter masks.
            `masks` includes three arrays with only 0/1 value:
            (1) masks[`intercept`] is a mask matrix for intercept matrix;
            (2) masks[`loading`] is a mask matrix for loading matrix;
            (3) masks[`corr`] is a mask matrix for correlation matrix.
            If an element in `masks` is zero, its corresponding element in `params` will not be updated in estimation.
        trace (list):
            A `list` to record the fitting history made by `fit()` method.
            `trace` is only available after using `fit()` method.
        eta (jax.numpy.ndarray):
            A 2D array with shape `(n_cases, n_factors)` for predicted `eta` values .
            The values of `eta` elements are calculated by averaging values of MH samples across `chains` specified in `fit()`.
            Therefore, it is not appropriate to directly use `eta` when `chains` is small.
            `eta` is only available after using `fit()` method.
        aparams (list):
            A `list` for averaged model parameter matrices.
            The averaging is with respect to all iterations in the stochastic approximation stage.
            `aparams` includes three parameter arrays:
            (1) `aparams[`intercept`]` is an intercept matrix with shape `(n_items, n_cats + 1)`;
            (2) `aparams[`loading`]` is a loading matrix with shape `(n_items, n_factors)`;
            (3) `aparams[`corr`]` is a correlation matrix with shape `(n_factors, n_factors)`.
            `aparams` is only available after using `fit()` method.
    """

    def __init__(
            self,
            data, n_factors,
            patterns=None,
            freq=None,
            init_frac=None,
            verbose=None,
            key=None):
        """__init__ Method for GRM Class
        Args:
            data (numpy.ndarray-like):
                A 2D array with shape `(n_cases, n_items)` to specify data for IFA.
                Its element must be a floating point with value from 0 to `n_cats` - 1,
                where `n_cats` is the number of categories.
                A missing value must be represented by `jax.numpy.nan` or `numpy.nan`.
            n_factors (int):
                An `int` to specify the number of factors in IFA.
            patterns (list, optional):
                A `list` to specify patterns for confirmatory analysis.
            freq (numpy.ndarray-like, optional):
                A 1D array with shape `(n_cases,)` to specify frequencies for rows of data.
                By default, `freq` is a 1D array of ones with shape `(n_cases,)`.
            init_frac (float, optional):
                A `float` between 0 and 1 to specify the percentage of cases for calculating sample statistics.
                The sample statistics is useful for initializing parameter values.
                `init_frac` is only required when data is too big with respect to the available memory.
                By default, `init_frac` is `1.0` (i.e., using all cases for computing sample statistics).
            verbose (bool, optional):
                A `bool` to specify whether model information should be printed after successful initialization.
                By default, `verbose` is `True`.
            key (numpy.ndarray-like, optional):
                A pseudorandom number generator (PRNG) key for random number generation.
                It can be generated by using `jax.random.PRNGKey(seed)`, where seed is an integer.
                In the initialization stage, `key` is only used if `init_frac` is specified.
                However, `key` will be largely used in `fit()` method (`key` can be also specified as an argument of `fit()`).
                By default, `key` is set by `jax.random.PRNGKey(0)`.
        """
        super().__init__(
            data=data,
            n_factors=n_factors,
            patterns=patterns,
            freq=freq,
            init_frac=init_frac,
            verbose=verbose,
            key=key)
        self.init_crf()
        self.init_masks()
        self.init_params()
        self.init_eta()
        self.print_init()

    def fit(self,
            lr=1.,
            max_iters=500,
            stem_iters=200,
            tol=10 ** (-4),
            window=3,
            chains=1,
            warm_up=5,
            jump_std="default",
            jump_change=.01,
            target_rate=.23,
            gain_decay=1.,
            corr_update="gd",
            batch_size=None,
            batch_shuffle=None,
            verbose=None,
            key=None,
            params=None,
            masks=None):
        super().fit(
            lr=lr,
            max_iters=max_iters,
            stem_iters=stem_iters,
            tol=tol,
            window=window,
            chains=chains,
            warm_up=warm_up,
            jump_std=jump_std,
            jump_change=jump_change,
            target_rate=target_rate,
            gain_decay=gain_decay,
            corr_update=corr_update,
            batch_size=batch_size,
            batch_shuffle=batch_shuffle,
            verbose=verbose,
            key=key,
            params=params,
            masks=masks)

    def init_crf(self):
        @jit
        def crf(eta, params):
            tau = -(eta @ params["loading"].T)[..., None] + params["intercept"]
            cr_prob = jnp.diff(
                jax.scipy.special.expit(tau),
                axis=-1)
            return cr_prob

        self.crf = crf

    def init_masks(self):
        super().init_masks()
        self.masks["intercept"] = jnp.hstack(
            [jnp.full(
                shape=(self.info["n_items"], 1),
                fill_value=0.,
                dtype=self.info["dtype"]),
                jnp.full(
                    shape=(self.info["n_items"],
                           self.info["n_cats"] - 1),
                    fill_value=1.,
                    dtype=self.info["dtype"]),
                jnp.full(
                    shape=(self.info["n_items"], 1),
                    fill_value=0.,
                    dtype=self.info["dtype"])])

    def init_params(self):
        def init_intercept(p1):
            n_items = p1.shape[0]
            intercept = jnp.hstack(
                [jnp.full((n_items, 1), -jnp.inf),
                 jax.scipy.special.logit(
                     jnp.cumsum(p1, axis=1)[:, :-1]),
                 jnp.full((n_items, 1), jnp.inf)])
            return intercept

        super().init_params()
        self.params["intercept"] = init_intercept(
            self.stats["p1"])
        del self.stats
